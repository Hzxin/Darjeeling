(bugzoo) chris@ctimperley-blade:~/git/darjeeling$ examples/repair.py
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:482; do_set_reverse(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:74; gcs_send_text(MAV_SEVERITY_WARNING, "Finished active loiter\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:252; loiter_duration = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:213; cliSerial->printf("&kleach_broke: %x\n", &kleach_broken);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:264; do_RTL();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:192; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:158; DataFlash.Log_Write_Trigger(ahrs, gps, current_loc);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:424; lateral_acceleration = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:179; gcs_send_message(MSG_CAMERA_FEEDBACK);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:197; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, g.throttle_min.get());]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:315; return verify_RTL();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:147; home_is_set = HOME_SET_NOT_LOCKED;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:222; next_navigation_leg_cd = mission.get_next_ground_course_cd(0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:78; set_next_WP(cmdloc);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:152; do_yaw(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:393; gcs_send_text_fmt(MAV_SEVERITY_NOTICE, "No commands. Can't set AUTO. Setting HOLD");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:150; DataFlash.Log_Write_Camera(ahrs, gps, current_loc);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:225; loiter_start_time = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:246; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:117; int32_t kleach_broken=0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:16; float target_speed = g.speed_cruise * guided_yaw_speed.target_speed * 2;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:48; cliSerial->printf("The bad guy won.\n");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:528; gcs_send_text(MAV_SEVERITY_WARNING, "NAV_SET_YAW_SPEED not recvd last 3secs, stopping");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:504; const int32_t steering = steerController.get_steering_out_angle_error(guided_yaw_speed.turn_angle);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:66; memset((void*)kleach_ints+(cmd.p1*sizeof(int32_t)), 0x1, 1);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:27; do_nav_wp(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:354; DataFlash.Log_Write_Camera(ahrs, gps, current_loc);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:350; active_loiter = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:44; log_picture();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:273; static_cast<int32_t>(fabsf(distance_past_wp)));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:170; cliSerial->printf("&kleach_broke: %x\n", &kleach_broken);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:455; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:188; do_loiter_time(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:39; condition_value = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:552; cliSerial->printf("kleach_broken: %x\n", kleach_broken);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:78; do_digicam_control(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:65; next_navigation_leg_cd = mission.get_next_ground_course_cd(0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:250; do_digicam_configure(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:299; do_yaw(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:325; condition_value = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:354; return true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:96; condition_value = condition_value + ahrs.yaw_sensor;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:36; return verify_RTL();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:188; distance_past_wp = wp_distance;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:352; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:88; float target_speed = g.speed_cruise * guided_yaw_speed.target_speed * 2;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:483; home_is_set = HOME_SET_NOT_LOCKED;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:16; log_picture();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:32; DataFlash.Log_Write_Camera(ahrs, gps, current_loc);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:317; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:551; memset((void*)kleach_ints+(cmd.p1*sizeof(int32_t)), 0x1, 1);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:219; previously_reached_wp = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:350; next_navigation_leg_cd = condition_value;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:358; gcs_send_text(MAV_SEVERITY_WARNING, "Finished active loiter\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:455; static_cast<int32_t>(fabsf(get_distance(current_loc, next_WP))));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:282; const int32_t steering = steerController.get_steering_out_angle_error(guided_yaw_speed.turn_angle);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:556; cliSerial->printf("The bad guy won.\n");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:21; loiter_duration = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:35; static_cast<uint32_t>(loiter_duration));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:507; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Cruise throttle: %.1f", static_cast<double>(g.throttle_cruise.get()));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:518; cmd.content.repeat_relay.cycle_time * 1000.0f);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:69; do_loiter_time(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:538; do_within_distance(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:527; next_WP = home;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:166; Location cmdloc = cmd.content.location;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:528; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Cruise speed: %.1f m/s", static_cast<double>(g.speed_cruise.get()));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:569; DataFlash.Log_Write_Mission_Cmd(mission, cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:69; gcs_send_text(MAV_SEVERITY_WARNING, "Finished active loiter\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:330; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:392; static_cast<int32_t>(fabsf(get_distance(current_loc, next_WP))));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:144; cliSerial->printf("&kleach_broke: %x\n", &kleach_broken);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:166; init_home();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:79; cliSerial->printf("The bad guy is ruining your buffer.\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:519; const int32_t error_to_target_yaw = abs((condition_value - ahrs.yaw_sensor));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:166; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:40; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:321; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Cruise speed: %.1f m/s", static_cast<double>(g.speed_cruise.get()));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:603; cmd.content.repeat_relay.cycle_time * 1000.0f);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:222; cmd.content.repeat_servo.repeat_count, cmd.content.repeat_servo.cycle_time * 1000.0f);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:427; do_set_reverse(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:318; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:225; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Executing command ID #%i", cmd.id);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:377; unsigned long addr = (unsigned long) kleach_ints + 5 * sizeof(int32_t);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:276; cliSerial->printf("The bad guy is ruining your buffer.\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:596; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:611; condition_value = -condition_value;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:465; set_reverse(false);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:404; next_navigation_leg_cd = mission.get_next_ground_course_cd(0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:596; do_loiter_unlimited(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:39; active_loiter = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:49; do_nav_wp(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:78; GCS_MAVLINK::send_home_all(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:73; int32_t kleach_broken=0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:6; do_loiter_time(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:521; calc_throttle(target_speed);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:276; camera.set_trigger_distance(cmd.content.cam_trigg_dist.meters);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:374; DataFlash.Log_Write_Mission_Cmd(mission, cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:568; condition_value = condition_value + ahrs.yaw_sensor;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:527; gcs_send_message(MSG_CAMERA_FEEDBACK);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:279; const int32_t steering = steerController.get_steering_out_angle_error(error_to_target_yaw);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:78; cliSerial->printf("*kleach_broke: %x\n", addr);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:166; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:611; return verify_RTL();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:596; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:604; ServoRelayEvents.do_set_servo(cmd.content.servo.channel, cmd.content.servo.pwm);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:392; Log_Write_GuidedTarget(guided_mode, Vector3f(steering, 0, 0), Vector3f(target_speed, 0, 0));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:617; condition_value = cmd.content.yaw.angle_deg * 100;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:48; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Executing command ID #%i", cmd.id);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:485; rtl_complete = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:95; gcs_send_message(MSG_CAMERA_FEEDBACK);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:273; unsigned long addr = (unsigned long) kleach_ints + 5 * sizeof(int32_t);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:73; condition_value = cmd.content.distance.meters;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:21; previously_reached_wp = true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:163; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:91; condition_value = cmd.content.yaw.angle_deg * 100;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:482; DataFlash.Log_Write_Camera(ahrs, gps, current_loc);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:470; const int32_t steering = steerController.get_steering_out_angle_error(error_to_target_yaw);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:289; home_is_set = HOME_SET_NOT_LOCKED;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:88; do_set_home(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:437; location_sanitize(current_loc, cmdloc);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:345; const int32_t steering = steerController.get_steering_out_angle_error(guided_yaw_speed.turn_angle);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:222; return false;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:163; in_auto_reverse = true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:596; return true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:170; next_navigation_leg_cd = mission.get_next_ground_course_cd(0);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:485; gcs_send_text_fmt(MAV_SEVERITY_NOTICE, "No commands. Can't set AUTO. Setting HOLD");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:318; return verify_within_distance();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:24; distance_past_wp = wp_distance;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:117; static_cast<int32_t>(fabsf(get_distance(current_loc, next_WP))));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:39; do_wait_delay(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:65; const int32_t steering = steerController.get_steering_out_angle_error(error_to_target_yaw);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:154; const int32_t error_to_target_yaw = abs((condition_value - ahrs.yaw_sensor));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:195; next_navigation_leg_cd = mission.get_next_ground_course_cd(0);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:377; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:477; in_auto_reverse = true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:353; next_navigation_leg_cd = condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:100; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, steering);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:298; lateral_acceleration = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:470; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:123; do_loiter_time(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:334; lateral_acceleration = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:613; condition_value = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:48; cliSerial->printf("Bug reached.\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:499; return verify_yaw();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:393; return false;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:16; next_WP = home;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:43; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:627; next_navigation_leg_cd = mission.get_next_ground_course_cd(0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:465; GCS_MAVLINK::send_home_all(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:178; lateral_acceleration = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:179; static_cast<uint32_t>(loiter_duration));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:333; distance_past_wp = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:27; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Executing command ID #%i", cmd.id);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:16; const bool result = verify_nav_wp(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:491; verify_nav_wp(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:521; set_reverse(true);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:231; set_reverse(false);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:551; gcs_send_text(MAV_SEVERITY_WARNING, "NAV_SET_YAW_SPEED not recvd last 3secs, stopping");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:358; Location cmdloc = cmd.content.location;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:404; g.throttle_cruise.set(cmd.content.speed.throttle_pct);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:31; distance_past_wp = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:403; do_set_reverse(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:318; gcs_send_text_fmt(MAV_SEVERITY_WARNING, "Skipping invalid cmd #%i", cmd.id);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:506; lateral_acceleration = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:197; ServoRelayEvents.do_set_servo(cmd.content.servo.channel, cmd.content.servo.pwm);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:288; camera_mount.set_mode_to_default();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:482; cliSerial->printf("kleach_broken: %x\n", kleach_broken);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:521; do_auto_rotation = false;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:21; loiter_duration = cmd.p1;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:216; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:334; return verify_RTL();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:228; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:325; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:100; do_loiter_unlimited(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:552; loiter_start_time = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:79; return verify_within_distance();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:44; camera.set_trigger_distance(cmd.content.cam_trigg_dist.meters);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:352; GCS_MAVLINK::send_home_all(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:481; int32_t kleach_ints[5];]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:519; GCS_MAVLINK::send_home_all(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:283; condition_value = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:35; const int32_t error_to_target_yaw = abs((condition_value - ahrs.yaw_sensor));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:73; loiter_start_time = millis();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:538; cmd.content.repeat_relay.cycle_time * 1000.0f);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:321; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Cruise throttle: %.1f", static_cast<double>(g.throttle_cruise.get()));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:315; cmd.content.repeat_relay.cycle_time * 1000.0f);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:56; cliSerial->printf("Bug reached.\n");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:195; home_is_set = HOME_SET_NOT_LOCKED;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:528; condition_value = cmd.content.distance.meters;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:350; loiter_duration = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:79; Log_Write_GuidedTarget(guided_mode, Vector3f(steering, 0, 0), Vector3f(target_speed, 0, 0));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:44; distance_past_wp = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:353; loiter_start_time += millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:427; return verify_within_distance();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:566; camera_mount.set_mode_to_default();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:500; static_cast<int32_t>(fabsf(distance_past_wp)));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:481; break;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:123; Log_Write_Home_And_Origin();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:52; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Cruise throttle: %.1f", static_cast<double>(g.throttle_cruise.get()));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:483; camera.set_trigger_distance(cmd.content.cam_trigg_dist.meters);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:437; do_wait_delay(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:480; gcs_send_text_fmt(MAV_SEVERITY_WARNING, "Skipping invalid cmd #%i", cmd.id);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:222; distance_past_wp = wp_distance;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:21; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:449; active_loiter = true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:57; log_picture();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:505; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);]>
Evaluating: <DELETE[APMrover2/commands_logic.cpp:500]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:16; do_auto_rotation = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:391; Log_Write_GuidedTarget(guided_mode, Vector3f(steering, 0, 0), Vector3f(target_speed, 0, 0));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:150; ServoRelayEvents.do_set_relay(cmd.content.relay.num, cmd.content.relay.state);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:66; camera.set_trigger_distance(cmd.content.cam_trigg_dist.meters);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:124; static_cast<int32_t>(fabsf(get_distance(current_loc, next_WP))));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:124; do_RTL();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:330; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:470; verify_nav_wp(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:568; g.speed_cruise.set(cmd.content.speed.target_ms);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:507; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, g.throttle_min.get());]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:568; next_navigation_leg_cd = condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:153; const bool result = verify_nav_wp(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:123; do_nav_wp(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:613; condition_value = condition_value + ahrs.yaw_sensor;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:440; control_mode = RTL;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:485; do_loiter_time(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:43; lateral_acceleration = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:264; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:216; do_set_home(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:99; Location cmdloc = cmd.content.location;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:188; init_home();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:564; camera.set_trigger_distance(cmd.content.cam_trigg_dist.meters);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:482; camera_mount.set_mode_to_default();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:123; condition_value = -condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:157; previously_reached_wp = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:225; do_set_reverse(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:32; home_is_set = HOME_SET_NOT_LOCKED;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:568; const int32_t steering = steerController.get_steering_out_angle_error(error_to_target_yaw);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:505; in_auto_reverse = false;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:113; loiter_duration = 0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:567; do_digicam_configure(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:498; camera_mount.set_mode_to_default();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:617; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:252; gcs_send_text_fmt(MAV_SEVERITY_WARNING, "Skipping invalid cmd #%i", cmd.id);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:568; int32_t kleach_ints[5];]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:477; cmd.content.repeat_servo.repeat_count, cmd.content.repeat_servo.cycle_time * 1000.0f);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:439; previously_reached_wp = false;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:564; log_picture();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:412; calc_throttle(g.speed_cruise);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:79; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:117; set_reverse(true);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:40; return result;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:468; camera_mount.set_roi_target(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:21; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, g.throttle_min.get());]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:70; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Executing command ID #%i", cmd.id);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:333; Location cmdloc = cmd.content.location;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:499; calc_throttle(g.speed_cruise);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:96; int32_t kleach_broken=0;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:334; return verify_loiter_unlimited(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:569; cliSerial->printf("The bad guy won.\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:27; cliSerial->printf("&kleach_broke: %x\n", &kleach_broken);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:630; return false;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:21; loiter_start_time = millis();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:552; camera_mount.set_mode_to_default();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:384; init_home();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:353; ServoRelayEvents.do_set_relay(cmd.content.relay.num, cmd.content.relay.state);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:192; gcs_send_text(MAV_SEVERITY_WARNING, "NAV_SET_YAW_SPEED not recvd last 3secs, stopping");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:225; mission.truncate(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:330; condition_start = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:383; ServoRelayEvents.do_set_servo(cmd.content.servo.channel, cmd.content.servo.pwm);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:154; gcs_send_text_fmt(MAV_SEVERITY_NOTICE, "No commands. Can't set AUTO. Setting HOLD");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:440; loiter_start_time += millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:506; int32_t kleach_ints[5];]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:317; set_reverse(true);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:250; gcs_send_text(MAV_SEVERITY_INFO, "Reached destination");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:179; const int32_t error_to_target_yaw = abs((condition_value - ahrs.yaw_sensor));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:333; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:564; mission.truncate(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:455; return verify_within_distance();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:298; do_digicam_control(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:527; in_auto_reverse = false;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:62; return verify_nav_wp(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:603; mission.truncate(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:39; condition_value = cmd.content.yaw.angle_deg * 100;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:27; return;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:528; gcs_send_text_fmt(MAV_SEVERITY_NOTICE, "No commands. Can't set AUTO. Setting HOLD");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:427; camera.trigger_pic(true);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:497; previously_reached_wp = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:276; calc_throttle(target_speed);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:69; camera.trigger_pic(true);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:377; static_cast<int32_t>(fabsf(get_distance(current_loc, next_WP))));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:298; cmd.content.repeat_relay.cycle_time * 1000.0f);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:96; gcs_send_text_fmt(MAV_SEVERITY_WARNING, "Skipping invalid cmd #%i", cmd.id);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:74; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:152; loiter_start_time = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:353; cliSerial->printf("The bad guy is ruining your buffer.\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:83; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:506; gcs_send_text(MAV_SEVERITY_WARNING, "NAV_SET_YAW_SPEED not recvd last 3secs, stopping");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:369; return result;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:556; return true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:527; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:219; next_navigation_leg_cd = condition_value;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:262; control_mode = RTL;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:393; previously_reached_wp = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:84; Location cmdloc = cmd.content.location;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:39; do_set_reverse(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:345; cliSerial->printf("kleach_ints: %x\n", kleach_ints);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:283; condition_start = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:617; static_cast<int32_t>(fabsf(distance_past_wp)));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:315; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Executing command ID #%i", cmd.id);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:289; do_set_home(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:61; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, g.throttle_min.get());]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:151; break;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:596; ServoRelayEvents.do_set_relay(cmd.content.relay.num, cmd.content.relay.state);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:99; g.speed_cruise.set(cmd.content.speed.target_ms);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:481; g.speed_cruise.set(cmd.content.speed.target_ms);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:384; SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:377; return false;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:96; return false;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:392; ServoRelayEvents.do_set_servo(cmd.content.servo.channel, cmd.content.servo.pwm);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:436; static_cast<int32_t>(fabsf(distance_past_wp)));]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:231; loiter_start_time = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:99; calc_throttle(g.speed_cruise);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:49; calc_throttle(g.speed_cruise);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:74; loiter_start_time += millis();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:178; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, steering);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:150; condition_value = -condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:158; cliSerial->printf("The bad guy is ruining your buffer.\n");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:352; do_yaw(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:70; const bool cmd_complete = verify_command(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:222; cmd.content.repeat_relay.cycle_time * 1000.0f);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:477; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, steering);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:481; do_wait_delay(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:100; distance_past_wp = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:24; break;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:144; return verify_yaw();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:228; GCS_MAVLINK::send_home_all(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:330; set_mode(HOLD);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:403; do_RTL();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:282; do_digicam_control(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:423; do_within_distance(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:551; condition_value = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:153; previously_reached_wp = true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:128; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:62; in_auto_reverse = true;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:485; verify_nav_wp(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:477; loiter_start_time = millis();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:567; verify_nav_wp(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:425; condition_value = -condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:556; condition_value = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:552; gcs_send_mission_item_reached_message(cmd.index);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:231; unsigned long addr = (unsigned long) kleach_ints + 5 * sizeof(int32_t);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:436; return result;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:497; return verify_wait_delay();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:219; calc_throttle(target_speed);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:569; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:222; Location cmdloc = cmd.content.location;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:383; Log_Write_Home_And_Origin();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:219; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:325; set_reverse(true);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:95; gcs_send_text(MAV_SEVERITY_WARNING, "Finished active loiter\n");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:424; loiter_duration = cmd.p1;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:352; lateral_acceleration = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:157; gcs_send_message(MSG_CAMERA_FEEDBACK);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:440; set_reverse(true);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:521; g.speed_cruise.set(cmd.content.speed.target_ms);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:31; mission.truncate(cmd.index);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:79; camera_mount.set_mode_to_default();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:197; calc_throttle(target_speed);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:499; do_digicam_control(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:73; const int32_t error_to_target_yaw = abs(condition_value - ahrs.yaw_sensor);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:5; condition_value = -condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:273; condition_value = condition_value + ahrs.yaw_sensor;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:498; do_within_distance(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:228; const float dist_to_wp = get_distance(current_loc, next_WP);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:299; gcs_send_text_fmt(MAV_SEVERITY_INFO, "Cruise throttle: %.1f", static_cast<double>(g.throttle_cruise.get()));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:396; return verify_within_distance();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:262; cliSerial->printf("&kleach_broke: %x\n", &kleach_broken);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:604; break;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:325; g.throttle_cruise.set(cmd.content.speed.throttle_pct);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:21; active_loiter = true;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:66; g.throttle_cruise.set(cmd.content.speed.throttle_pct);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:566; Location cmdloc = cmd.content.location;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:282; loiter_duration = cmd.p1;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:424; memset((void*)kleach_ints+(cmd.p1*sizeof(int32_t)), 0x1, 1);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:552; return false;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:315; gcs_send_text(MAV_SEVERITY_INFO, "Reached destination");]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:250; home_is_set = HOME_SET_NOT_LOCKED;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:252; int32_t kleach_ints[5];]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:53; g.throttle_cruise.set(cmd.content.speed.throttle_pct);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:153; cliSerial->printf("kleach_broken: %x\n", kleach_broken);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:392; set_reverse(true);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:584; memset((void*)kleach_ints+(cmd.p1*sizeof(int32_t)), 0x1, 1);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:404; do_within_distance(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:5; condition_start = millis();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:95; cliSerial->printf("kleach_broken: %x\n", kleach_broken);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:61; do_wait_delay(cmd);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:506; return verify_nav_wp(cmd);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:604; ServoRelayEvents.do_set_relay(cmd.content.relay.num, cmd.content.relay.state);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:498; loiter_start_time += millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:465; loiter_duration = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:473; camera_mount.set_roi_target(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:617; break;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:360; gcs_send_text_fmt(MAV_SEVERITY_NOTICE, "No commands. Can't set AUTO. Setting HOLD");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:345; condition_value = -condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:32; int32_t kleach_ints[5];]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:518; GCS_MAVLINK::send_home_all(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:213; memset((void*)kleach_ints+(cmd.p1*sizeof(int32_t)), 0x1, 1);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:491; g.throttle_cruise.set(cmd.content.speed.throttle_pct);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:32; DataFlash.Log_Write_Trigger(ahrs, gps, current_loc);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:283; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:56; Log_Write_GuidedTarget(guided_mode, Vector3f(steering, 0, 0), Vector3f(target_speed, 0, 0));]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:6; next_navigation_leg_cd = condition_value;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:231; ServoRelayEvents.do_set_servo(cmd.content.servo.channel, cmd.content.servo.pwm);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:566; init_home();]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:65; camera_mount.set_roi_target(cmd.content.location);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:473; SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:631; ahrs.set_home(cmd.content.location);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:439; return cmd_complete;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:384; set_mode(HOLD);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:40; cliSerial->printf("kleach_broken: %x\n", kleach_broken);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:273; condition_value = 0;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:410; log_picture();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:507; in_auto_reverse = false;]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:153; cliSerial->printf("Bug reached.\n");]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:363; Location cmdloc = cmd.content.location;]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:95; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:393; location_sanitize(current_loc, cmdloc);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:630; condition_start = millis();]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:44; gcs_send_message(MSG_CAMERA_FEEDBACK);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:507; cmd.content.digicam_configure.engine_cutoff_time);]>
Evaluating: <APPEND[APMrover2/commands_logic.cpp:99; const int32_t steering = steerController.get_steering_out_angle_error(error_to_target_yaw);]>
Evaluating: <REPLACE[APMrover2/commands_logic.cpp:158; GCS_MAVLINK::send_home_all(cmd.content.location);]>
FOUND REPAIR: <APPEND[APMrover2/commands_logic.cpp:32; int32_t kleach_ints[5];]>
FOUND REPAIR: <REPLACE[APMrover2/commands_logic.cpp:158; GCS_MAVLINK::send_home_all(cmd.content.location);]>
